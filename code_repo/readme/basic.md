# Python的入门基础概念整理（不完全版）

## 一、一些基本的注意事项

### 1.1、Python代码规范问题

参考官方推荐的PEP-8的代码风格：
https://www.python.org/dev/peps/pep-0008/

### 1.2、语言特点

`解释型语言`：没有编译环节  
`面向对象`：python中，一切皆对象，每个对象由：标识（identity，对象在内存中的地址）、类型（type）、值（value）组成  
`强类型`：每个对象都有数据类型，且只支持该类型支持的操作  
`动态类型`：变量不需要显式声明类型，根据变量引用的对象，python解释器会自动确定数据的类型

### 1.3、对象

对象的本质就是一个**内存块**，拥有特定的值，支持特定类型的相关操作。  
python中，一切皆对象。每个对象由：标识（identity，对象在内存中的地址）、类型（type）和值（value）组成。   
`标识`：用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数 id(obj) 可返回对象obj的标识。  
`类型`：用于表示对象存储的“数据”的类型。类型可以限制对象的取值范围以及可执行的操作。可以使用 type(obj) 获得对象的所属类型。  
`值`：表示对象所存储的数据的信息。使用print(obj)可以直接打印出值。

### 1.4、引用

在python中，变量是对象的引用。变量存储的是对象的地址，变量通过地址引用对象。  
变量位于*栈内存*中；对象位于*堆内存*中。

### 1.5、垃圾回收机制

### 1.6、整数缓存问题

命令行下，python仅对 [-5,256] 范围内的整数对象进行缓存，但不是所有的整数对象。  
pycharm或保存为文件后的缓存范围为 [-5,无限大正整数]。  
也可能pycharm版本不同会出现不同的范围限制。

### 1、7、序列

+ 序列是一种数据存储方式，用来存储一系列的数据。
+ 在内存中，序列就是一块用来存放多个值的连续的内存空间。
+ 序列中存储的其实是对象的地址，而不是对象的值。
+ python中常用的序列结构有：字符串、列表、元组和字典。

![](C:\code\PythonProject\python_start\readme\figure\内存中序列示意图.png)

## 二、Python开发环境

### 2.1、Pycharm本地开发

### 2.2、远程开发

### 2.3、协作开发

#### 2.3.1、分支管理

## 三、Python基础语法

基础入门可以参考菜鸟教程：  
https://www.runoob.com/python/python-tutorial.html

### 3.1、标识符

python中，标识符由字母、数字、下划线组成。  
标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。  
标识符区分大小写。

### 3.2、变量类型

变量存储在内存中的值意味着在创建变量时会在内存中开辟一个空间。  
基于变量的数据类型，解释器会分配指定的内存，并决定什么数据可以被存储在内存中。   
因此，变量可以指定不同的数据类型，这些变量可以存储整数、小数或字符等。  
`变量赋值`：python中的变量赋值不需要类型声明；每个变量在内存中创建（包括变量的标识、名称和数据等信息）；每个变量在使用前必须赋值，变量赋值后该变量才会被创建。  
`链式赋值`：用于同一个对象赋值给多个变量。 x=y=123 <==> x=123 y=123  
`系列解包赋值`：系列数据赋值给对应相同个数的变量（个数必须保持一致）。  
使用系列解包赋值可以实现变量的交换： a,b=1,2 a,b=b,a

### 3.3、标准数据类型

python定义了五种标准的数据类型，用于存储各种类型的数据。  
`Number`
：数字数据类型用于存储数值，python支持四种不同的数字类型（int,long（long类型只存在于python2.x版本中）,float,complex）。（在python3.x版本中，long类型被移除，使用int替代）    
`String`：字符串是由数字、字母、下划线组成的一串字符。字符串列表截取方式：[头下标:尾下标]               
`List`：列表是python中使用最频繁的数据类型，python最通用的复合数据类型。支持字符、数字、字符串或者嵌套列表。列表使用[ ]标识，属于有序的对象集合。                    
`Tuple`：元组使用( )标识，内部元素用逗号隔开，但不能二次赋值，相当于**只读列表**（即，元组不允许更新）。                
`Dictionary`：字典是除列表以外python中最灵活的内置数据结构类型，是无序的对象集合。字典中的元素通过键存取，无法通过偏移存取。字典使用{ }标识，由索引key和对应的值value组成。

### 3.4、数据类型转换

`int()`:转换为整数  
`long()`:转换为长整数  
`float()`:转换为浮点数  
`complex()`:创建一个复数  
`str()`:转换为字符串  
`repr()`:将对象转换为供解释器读取的形式(https://www.runoob.com/python/python-func-repr.html)  
`eval()`:计算在字符串中的有效python表达式，并返回表达式的值 (https://www.runoob.com/python/python-func-eval.html)   
`tuple()`:转换为元组  
`list()`:转换为列表  
`set()`:转换为可变集合  
`dict()`:创建字典  
`frozenset()`:转换为不可变集合，返回的集合被冻结，不可以再添加或删除任何元素(https://www.runoob.com/python/python-func-frozenset.html)

### 3.5、运算符

#### 3.5.1、算数运算符

`+`:加  
`-`:减  
`*`:乘  
`/`:除以  
`%`:取余  
`**`:幂次  
`//`:取整

#### 3.5.2、比较运算符

`==`:比较两个对象是否相等，返回True False  
`!=`:不相等   
`>`:返回是否大于  
`<`:返回是否小于  
`>=`:返回是否大于等于  
`<=`:返回是否小于等于

#### 3.5.3、赋值运算符

赋值符和运算符组合形成赋值运算符。  
`=`:赋值  
`+=`:加法赋值   
`-=`:  
`*=`:  
`/=`:  
`%=`:  
`**=`:  
`//=`:

#### 3.5.4、位运算符

`&`：位与运算符  
`|`：位或运算符  
`^`：位异或运算符  
`~`：位取反  
`<<`：左移动  
`>>`：右移动

#### 3.5.5、逻辑运算符

`and`:与  
`or`:或  
`not`:非

#### 3.5.6、成员运算符

`in`:若在指定的序列中找到值返回True，否则返回False  
`not in`:若没有返回True

#### 3.5.7、身份运算符

`is`:判断两个标识符是否引用自一个对象。 x is y <==> id(x) == id(y)  
`is not`:判断是否引用自不同的对象

#### 3.5.8、运算符优先级

** ：指数运算符最高优先级  
~+/- ：按位翻转  
/ * % /// ：乘除取余取整

具体参考如下链接：  
https://www.runoob.com/python/python-operators.html

## 3.6、语句

### 3.6.1、条件语句

python条件语句是通过一条或多条语句的执行结果来决定执行的代码块。

![条件语句示意图](C:\code\PythonProject\python_start\readme\figure\条件语句.png)

python编程中if语句用于控制程序的执行，基本形式为：

    if 判断条件1:
        执行语句1
    elif 判断条件2:
        执行语句2
    else:
        执行语句3

### 3.6.2、循环语句

python提供了for循环和while循环，但没有do...while...

![循环语句示意图](C:\code\PythonProject\python_start\readme\figure\循环语句.png)

| 控制语句 | 描述 |  
|:----:|:----:|
| break语句 | 在语句块执行过程中终止循环，并且跳出整个循环。 |  
|continue语句 |在语句执行过程中终止当前循环，跳出该次循环后执行下一次循环。|  
|pass语句  |pass是空语句，为了保持程序结构的完整性而存在。|  

## 四、字符串

### 4.1、基本特点

+ python不支持单字符类型，单字符在python中是作为一个字符串使用的。
+ python访问子字符串的时候，可以使用方括号[]来截取字符串。
+ 字符串的本质是*字符序列*。因此python的字符串是不可变的，故无法对原字符串做任何修改。
+

### 4.2、转义字符

| 转义字符 | 描述 |  
| :----: | :-----: |  
| \ | 续行符 |  
| \\ | 反斜杠符 |  
| \' | 单引号 |  
| \b | 双引号 |  
| \n | 换行 |  
| \r | 回车 |
| \f | 换页 |

### 4.3、字符串运算符

|操作符|描述|  
|:----:|:----:|  
|+|字符串连接|  
|*|重复输出字符串|  
|[]|索引获取字符串中的字符|  
|in|成员运算符，包含返回True|  

### 4.4、Unicode字符串

+ python中定义一个Unicode字符串和定义一个普通字符串一样简单。方法： u"字符串"
+ Unicode，称为统一码，是计算机科学领域里的一项业界标准，包括字符集、编码方案等。
+ 是为了解决窗体的字符编码方案的局限性产生的，为每种语言中的每个字符设定了统一且唯一的二进制编码，以满足跨语言、跨平台进行文本交换和处理的要求。
+ python3直接支持Unicode，默认是16位的Unicode编码，ASCII码是Unicode编码的子集。
+ 可以使用内置函数ord()将字符转换位对应的Unicode码；使用内置函数chr()将十进制数字转换为对应的字符。

### 4.5、字符串内建函数

|方法|描述|  
|:----:|:----:|  
|string.capitalize()|把字符串的第一个字符大写|  
|string.center(width)|返回一个原字符串居中，并使用空格填充至长度width的新字符串|  
|string.count(str,beg=,end=)|返回str在string里出现的次数，beg和end返回指定范围内str出现的次数|  
|string.endswith(obj,beg=,end=)|检查字符串是否以obj结束，beg和end指定检查的范围|  
|string.find(str,beg=,end=)|检查str是否包含在string中|

### 4.6、字符串切片slice

切片slice操作可以让我们快速提取字符串，标准格式为：

    [起始偏移量start:终止偏移量end:步长step]

### 4.7、replace

修改字符串

### 4.8、split()和join()

+ split()可以基于指定分隔符将字符串分割成多个子字符串（存储到列表中）
+ join()可以将一系列的子字符串连接起来.标准格式为：str.join(sequence)
+ 字符串拼接符使用 + 时，会生成新的字符串对象，占用内存，故不推荐使用。推荐使用join函数，因为join函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝，仅新建一次对象。
+

### 4.9、字符串驻留机制

- `字符串驻留`：仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。
- python支持字符串驻留机制，对符合标识符规则的字符串（仅包含下划线、字母、数字）会启用字符串驻留机制。
- https://hk4fun.github.io/2018/11/07/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%A9%BB%E7%95%99%E6%9C%BA%E5%88%B6/
-

### 4.10、可变字符串

+ io.StringIO对象或array模块

## 五、列表list

序列是python中最基本的数据结构，序列中的每个元素都分配一个数字——位置 + 索引。

### 5.1、基本注意点

+ 列表的数据项不需要具有相同的类型，创建一个列表只需要把逗号分隔的不同的数据项使用方括号括起来即可。
+ 列表是内置可变序列，是包含多个元素的有序连续的内存空间。

### 5.2、列表的方法

|方法|描述|  
|:----:|:----:|  
|cmp(list1,list2)|若比较的元素是同类型的，则比较值，返回结果。若不是同一类型的，则检查是否是数字|  
|list(seq)|将元组转换为列表|  
|list.append(obj)|在列表末尾添加新的对象|  
|list.count(obj)|统计某个元素在列表中出现的次数|  
|list.extend(seq)|在列表末尾一次性追加另一个序列中的多个值，用新列表扩展原来的列表|  
|list.index(obj)|从列表中找出某个值第一个匹配项的索引位置|  
|list.insert(index,obj)|将对象插入列表|  
|list.pop([index = -1])|移除列表中的一个元素，默认是最后一个元素，并且返回该元素的值|  
|list.remove(obj)|移除列表中某个值的第一个匹配项|  
|list.reverse()|反向列表中的元素|  
|list.sort(cmp=,key=,reverse=)|对原列表进行排序|

### 5.3、列表创建

`法一`：直接创建

    a = []
    a = [10, 20, "asd"] 

`法二`：list()

    a = list()
    b = list(range(10))
    c = list("dad")

`法三`：range([start],end,[step])

    a = list(range(3,15,2))

`法四`：推导式

    a = [x*2 for x in range(100) if x%9 == 0]
    b = [x*2 for x in range(5)]

### 5.4、列表元素添加的方法_效率

`extend()`:将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象。*两个列表相加的时候推荐使用*
`append()`：在列表尾部添加新的元素，速度最快。*增加单个元素的时候推荐使用*  
`+运算符`:创建新的列表对象，将原列表的元素和新列表的元素依次复制到新的列表对象中，这样会涉及大量的复制操作。  
`insert()`：将指定的元素插入到列表对象的任意指定位置，会使得列表中的所有元素进行移动，影响处理速度。*涉及大量元素时应该尽量避免使用。*  
`乘法扩展`：使用乘法扩展列表生成一个新的列表，新列表是原列表元素的多次重复。

### 5.5、列表元素的删除方法

`del`：删除列表指定位置的元素。(其实原理上是将指定位置后的所有元素依次复制到前面一个元素的位置，从而达到表面上删除指定位置元素的效果)  
`pop()`：删除并返回指定位置元素，默认是最后一个。    
`remove()`：删除首次出现的指定元素，不存在抛出异常。

### 5.6、列表遍历

    for obj in listobj:
        print(obj)

### 5.7、多维列表

+ 一维列表存储一维、线性的数据。
+ 二维列表存储二维、表格的数据。
+

## 六、元组tuple

### 6.1、元组的基本特点

+ 元组使用小括号()
+ 当元组中只包含一个元素时，需要在元素后面添加逗号,
+ 不可变序列，不能修改元组中的元素，没有增加、删除、修改元素的方法

### 6.2、创建和删除元组

+ tuple() 可以接收 列表、字符串、其他序列类型、迭代器等生成元组。
+ del

### 6.3、索引访问

使用[67]索引范文即可，但不支持修改。

### 6.4、生成器推导式创建元组

+ 生成器推导式生成的不是列表也不是元组，而是一个生成器对象。

    s1 = (x*2 for x in range(5))
    print(tuple(s1))
    s2 = (x*3 for x in range(4))
    print(list(s2))

### 6.5、排序

使用内置函数 sorted(tupleobj) 对元组进行排序后生成新的列表对象。

## 七、字典dictionary

### 7.1、字典基本特点

+ 字典是“键值对”的无序可变序列，可以存储任意类型的对象。
+ 键可以是任意不可变的数据，整数、浮点数、字符串、元组，但是列表、字典、集合这些可变对象不能作为键。
+

    d = {key1:value1,key2:value2}

### 7.2、字典创建的方式

`{}`:  
`dict()`:  
`zip()`:  
`fromkeys()`:

### 7.3、字典元素的访问

+ 通过 键 获得 值
+ 通过 get() 方法获得 值
+ items()
+ dict.keys() / dict.values()
+

### 7.4、字典元素的添加、修改和删除

+ update()
+ del() / clear() / pop()
+ popitem(): 随机删除和返回该键值对

### 7.5、序列解包

+ 序列解包可以用于元组、列表、字典，可以方便我们对多个变量赋值。

### 7.6、字典的核心底层原理

+ 字典对象的核心是 散列表。（散列表是一个稀疏数组，数组的每个单元叫bucket，每个bucket有两部分，一个是 键对象的引用，一个是值对象的引用）

## 八、函数

+ 函数是**可重用**的程序代码块。函数的作用不仅可以实现代码的复用，还能实现代码的一致性。一致性是指只要修改函数的代码，则所有调用该函数的地方都能得到体现。
+ 函数是代码复用的通用机制。在Java中叫方法。
+ python中函数分为几类： 内置函数（str()、list()等）；标准库函数（import 导入）；第三方库函数；用户自定义函数。
+ 函数也是对象。

### 8.1、函数基本知识点

- 形参，实参
- 文档字符串，函数的注释 '''  '''
- return返回值（列表、元组、字典、集合）
-

### 8.2、lambda 和 eval

+ lambda表达式可以用来声明匿名函数，是一种简单的、在同一行中定义函数的方法，lambda函数实际上是生成了一个函数对象。
+ lambda表达式只允许包含一个表达式，不能包含复杂语句。

- eval 功能是将字符串str当成有效的表达式来求值并返回计算结果

### 8.3、LEGB规则

+ python在查找”名称“时按照LEBG规则查找：Local(函数或类的方法内部) --> Enclosed(嵌套函数，闭包) --> Global(模块中的全局变量) --> Built in(python为自己保留的特殊名称)

## 九、面向对象

+ 面向对象 (object oriented programming, OOP) 编程的思想主要是针对大型软件设计而来的。
+

### 9.1、面向对象和面向过程的区别

*自行谷歌*

### 9.2、类

#### 9.2.1、类的定义

+ 对象是类的具体实体，即 类的实例。
+ 从一个类创建对象时，每个对象会共享这个类的行为(类中定义的方法)，但会有自己的属性值(不共享状态)。即 方法代码是共享的，但属性数据不共享。
+ 可以通过类定义数据类型的属性(数据)和方法(行为)。

![](C:\code\PythonProject\python_start\readme\figure\类.png)

#### 9.2.2、构造函数__init__()

+ __init__() 函数 名称固定，第一个参数必须是self（类似java中的this关键字），self就是刚刚创建好的实例对象
+

#### 9.2.3、访问属性

`getattr(obj, name)`访问对象属性  
`hasattr(obj, name)`检查是否存在一个属性  
`setattr(obj, name, value)`设置一个属性，若属性不存在，则创建新的属性  
`delattr(obj, name)`删除属性

#### 9.2.4、内置类属性

`__dict__`类的属性（包含一个字典，由类的数据属性组成）  
`__doc__`类的文档字符串  
`__name__`类名  
`__module__`类定义所在的模块  
`__bases__`类的所有父类构成元素，包含一个由所有父类组成的元组

#### 9.2.5、垃圾回收

+ python使用 引用计数 来实现跟踪和回收垃圾(在 Python 内部记录着所有使用中的对象各有多少引用。 一个内部跟踪变量，称为一个引用计数器。当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说，
  这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是"立即"的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。)
+ 垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python
  的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。

#### 9.2.6、类的继承

+ 通过继承创建的新类称为 子类或派生类，被继承的类称为基类、父类或超类。
+ 如果在子类中需要父类的构造方法，就需要显式地调用父类的构造方法，或者不重写父类的构造方法。(情况一：子类需要自动调用父类的方法：子类不重写__init__()方法，实例化子类后，会自动调用父类的__init__()的方法。
  情况二：子类不需要自动调用父类的方法：子类重写__init__()方法，实例化子类后，将不会自动调用父类的__init__()的方法。 情况三：子类重写__init__()方法又需要调用父类的方法：使用super关键词：)
+ 在调用基类的方法时，需要加上基类的类名前缀，且需要带上self参数变量。但在类中调用普通函数时并不需要带上self参数。
+ python先在本类中查找调用的方法，找不到才去基类中找。
+ 如果在继承元组中列了一个以上的类，那么就称为”多重继承“。
+ 如果父类的方法的功能不能满足需求，则可以在子类重写父类的方法。
+ 如果在类定义中没有指定父类，则默认父类是object类。即object类是所有类的父类，里面定义了一些所有类共有的默认实现，比如:__new__()
+

#### 9.2.7、基础重载方法

|方法|描述|  
|:----:|:----:|  
|__init__()|构造函数|  
|__del__()|删除对象| 
|__repr__()|转化为解释器读取的形式|  
|__str__()|将值转换为适合阅读的形式|  
|__cmp__()|对象比较|

#### 9.2.8、运算符重载

#### 9.2.9、类属性和方法

+ 类的私有属性： __private_attrs 两个下划线开头声明该属性为私有，不能在类的外部被使用或者直接访问。在类内部的方法中使用是 self.__private_attrs。
+ 类的方法： 使用def关键字定义方法
+ 类的私有方法： __private_method 两个下划线开头声明该方法为私有方法，不能在类的外部调用。在类的内部调用要用 self.__private_methods
+ 头尾双下划线定义的是特殊方法，一般是系统定义的名字；双下划线表示的是私有类型private的变量，只能允许这个类本身进行访问；单下划线开头的是保护类型的变量(protected类型)，只能允许其本身与子类进行访问。
+ 类方法是从属于”类对象“的方法，类方法通过装饰器@classmethod来定义。
+ python中允许定义与”类对象“无关的方法，称为静态方法。静态方法与在模块中定义普通函数没有区别，只不过静态方法放到了类的名字空间里面，需要通过类调用。
+ 静态方法通过装饰器@staticmethod来定义。@staticmethod必须位于方法上面一行，调用静态方法格式：`类名.静态方法名(参数列表)'。静态方法中访问实例属性和实例方法会导致错误。
+

#### 9.2.10、垃圾回收机制

+ __del__方法称为”析构方法“，用于实现对象被销毁时所需的操作。
+ python实现自动的垃圾回收，当对象没有被引用时，由垃圾回收器调用__del__方法。
+ 系统会自动提供__del__方法，一般不需要自定义析构方法。

#### 9.2.11、可调用对象

+ 定义了__call__方法的对象，称为”可调用对象“，即该对象可以像函数一样被调用。
+

#### 9.2.12、@property装饰器

@property可以将一个方法的调用方式变成”属性调用“。

#### 9.2.12、面向对象语言三大特征

+ 封装：隐藏对象的属性和实现细节，只对外提供必要的方法。
+ 继承：让子类具有父类的特性，提高代码的重用性。
+ 多态：同一个方法调用由于对象不同会产生不同的行为。

#### 9.2.13、多重继承

#### 9.2.14、super超类











