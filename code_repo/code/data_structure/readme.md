# 数据结构和算法

## 一、基本概念和术语

### 1.1、数据

+ 数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。
+ 数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。
+ 数据项是数据不可分割的最小单位
+ 数据对象是性质相同的数据元素的集合，是数据的子集。
+ 数据结构是相互之间存在一种或多种特定关系的数据元素的集合。

### 1.2、结构

`逻辑结构`：数据对象中数据元素之间的相互关系。

+ 集合结构 中的数据元素除了同属于一个集合外，互相之间没有其他关系。
+ 线性结构 中的数据元素之间是一对一的关系。
+ 树形结构 树形结构中的数据元素之间存在一种一对多的层次关系。
+ 图形结构 图形结构的数据元素是多对多的关系。

`物理结构`： 数据的逻辑结构在计算机中的存储形式。

+ 顺序存储结构 将数据元素存放在地址连续的存储单元里，数据间的逻辑关系和物理关系是一致的。
+ 链式存储结构 把数据元素存放在任意的存储单元里，这组存储单元可以是连续的也可以是不连续的。
+

### 1.3、算法

+ 算法 是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。
+ 算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。
+ 好的算法应该具有正确性、可读性、健壮性、高效率和低存储量的特征。
+ 算法时间复杂度

### 1.4、线性表

#### 1.4.1、线性表的抽象数据类型表示

线性表list 是 0个或多个数据元素的有限序列。 (序列 --> 元素之间是有顺序的，有限的)

若将线性表记为$\(a_1, a_2, ..., a_i, ..., a_n\)$，则表中的 $\(a_(i-1)\)$领先于$\(a_i\)$，$\(a_i\)$领先于$\(a_(i+1)\)$，称$\(a_(i-1)\)$
是$\(a_i\)$的直接前驱元素，$\(a_(i+1)\)$是$\(a_i\)$的直接后继元素。当i=1、2、3...，$\(a_i\)$ 有且仅有一个直接后继，当i=2、3、n时，$\(a_i\)$有且仅有一个直接前驱。i是位序。

所以，线性表元素的个数n定义为线性表的长度，n=0时称为空表。

+ 线性表的抽象数据类型定义如下：

        ADT 线性表(Lsit)
        Data
            线性表的数据对象集合为{a1,a2,a3,...,an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除最后一个元素an外，
        每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
        Operation
            InitList(*L);  初始化操作，建立一个空的线性表L
            ListEmpty(L);  若线性表为空，返回True，否则返回Flase
            ClearList(*L);  将线性表清空
            GetElem(L, i, *e);  将线性表L中的第i个位置元素返回给e
            LocateElem(L, e);  在线性表L中查找与给定值e相等的元素，若查找成功，返回该元素在表中序号表示成功，否则返回0表示失败
            ListInsert(*L, i, e);  在线性表L中的第i个位置插入新元素e
            ListDelete(*L, i, *e);  删除线性表L中的第i个位置元素，并用e返回其值
            ListLength(L);  返回线性表L的元素个数
        endADT

对于不同的应用，线性表的基本操作是不同的，上述操作是最基本的，对于实际问题中涉及的关于线性表的更复杂操作，完全可以用这些基本操作的组合实现。  
比如，要实现两个线性表集合A和B的并集操作，就是把存在集合B中但并不存在A中的数据元素插入到A中即可。所以只要循环集合B中的每个元素，判断当前元素是否存在A中， 若不存在，插入到A中即可。  
假设La表示集合A，Lb表示集合B，则实现的代码如下：

    void union(List *La, List Lb)
    {
        int La_len, Lb_len, i;
        ElemType e;  # 声明与La和Lb相同的数据元素e
        La_len = ListLength(La);  # 求线性表的长度
        Lb_len = ListLength(Lb);
        for(i =1; i <= Lb_len; i++)
        {
            GetElem(Lb, i, *e);  # 取Lb中第i个数据元素赋给e
            if(!LocateElem(La, e, equal))  # La中不存在和e相同的数据元素
                ListInsert(La, ++La_len, e);  # 插入
        }
    }

#### 1.4.2、线性表的顺序存储结构

`线性表的顺序存储结构`: 用一段地址连续的存储单元依次存储线性表的数据元素。

    线性表的顺序存储的结构代码：
    # define MAXSIZE 20  # 存储空间初始分配量
    typedef int ElemType;  # ElemType类型根据实际情况而定，这里假设为int类型
    typedef struct
    {
        ElemType data[MAXSIZE];  # 数组存储数据元素，最大值为MAXSIZE
        int length;  # 线性表当前长度
    }
    SqList;

在这里可以发现，描述顺序存储结构需要三个属性：

+ 存储空间的起始位置：数组data，它的存储位置就是存储空间的存储位置。
+ 线性表的最大存储容量：数组长度MAXSIZE。
+ 线性表的当前长度：length

**数组的长度是指存放线性表的存储空间的长度，线性表的长度是线性表中数据元素的个数。在任意时刻，线性表的长度应该小于等于数组的长度**

    顺序存储结构*获得元素*的操作：对于线性表的顺序存储结构来说，如果要实现GetElem操作，即将线性表L中的第i个位置元素值返回，
    只要i的数值在数组下标范围内，就是把数组第i-1下标的值返回即可。
    #define OK 1
    #define ERROR 0
    #define TRUE 1
    #define FALSE 0
    typedef int Status;  
    # status是函数的类型，值是函数结果状态代码，如OK等
    # 初始条件：顺序线性表L已存在
    # 操作结果：用e返回L中第i个数据元素的值
    Status GetElem(SqL L, int i, ElemType *e)
    {
    if(L.length == 0 || i < 1 || i > L.length)
        return ERROR;
    *e = L.data[i - 1]
    return OK;
    }
        
    插入算法的思路：1.如果插入位置不合理，抛出异常；2.如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
    3.从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；4.将要插入元素填入位置i处；5.表长加1。
    # 初始条件：顺序线性表L已存在
    # 操作结果： 在L中第i个位置之前插入新的数据元素e，L的长度加1
    Status ListInsert(SqList *L, int i, ElemType e)
    {
    int k;
    if (L -> length == MAXSIZE)
        return ERROR;
    if (i < 1 || i > L -> length + 1)
        return ERROR;
    if (i <= L -> length)
    {
        for (k = L -> length - 1; k >= i - 1; k--)
            L -> data[k + 1] = L -> data[k];
    }
    L -> data[i - 1] = e;
    L -> length++;
    return OK;
    }
    
    删除算法的思路：1.如果删除位置不合理，抛出异常；2.取出删除元素；3.从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；
    4.表长-1.
    # 初始条件： 顺序线性表L已存在
    # 操作结果： 删除L的第i个数据元素，并用e返回其值，L的长度-1
    Status ListDelete(SqList *L, int i, ElemType *e)
    {
    int k;
    if (L -> length == 0)  # 线性表为空
        return ERROR;
    if (i < 1 || i > L -> length)  # 删除位置不正确
        return ERROR;
    *e = L -> data[i - 1];
    if (i < L -> length)  # 如果删除不是最后位置
    {
    for (k = i; k < L -> length; k++)  # 将删除位置后继元素前移
        L -> data[k - 1] = L -> data[k];
    }
    L -> length--;
    return OK;
    }

线性表顺序存储结构的优缺点：  
`优点`:

+ 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
+ 可以快速地存取表中任一位置的元素

`缺点`:

+ 插入和删除操作需要移动大量元素
+ 当线性表长度变化较大时，难以确定存储空间的容量
+ 造成存储空间的“碎片”

#### 1.4.3、线性表的链式存储结构

在链式结构中，对于任意一个数据元素ai来说，除了要存储其本身的信息之外，还需要鵆一个指示其直接后继的信息(即直接后继的存储位置)。
我们将存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称为指针/链。这两部分信息组成数据元素ai的存储 映像，称为结点(Node)。

+ n个结点(ai的存储映像)链结成一个链表，即为线性表(a1,a2,...,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以称为 单链表。
+ 链表的第一个结点叫做头指针，链表的最后一个结点指针为NULL空。

`头指针`: 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针；头指针具有标识作用，所以常用头指针冠以链表的名字； 无论链表是否为空，头指针均不为空。头指针是链表的必要元素。

`头结点`: 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前(第一结点之前)，其数据域一般无意义(也可存放链表的长度)；有了头结点，对在第一元素
结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了；头结点不一定是链表必须要素。

线性表链式存储结构代码描述：

    # 线性表的单链表存储结构
    typedef struct Node
    {
        ElemType data;  # 结点由存放数据元素的数据域和存放后继结点地址的指针域组成
        struct Node *next;
    }
    Node;
    typedef struct Node *LinkList;  # 定义LinkList

#### 1.4.4、单链表的读取

由于单链表的结构中没有定义表长，所以事先不知道要循环多少次，故不方便使用for循环控制。其主要的核心思想就是**工作指针后移**。

    获得链表的第i个数据的算法思路：1.声明一个结点p指向链表第一个结点，初始化j从1开始；2.当j<i时，就遍历链表，让p的指针向后
    移动，不断指向下一结点，j累加1；3.若到链表末尾，p为空，则说明第i个元素不存在；4.否则查找成功，返回结点p的数据。
    # 初始条件：链式线性表L已存在
    # 操作结果：用e返回L中第i个数据元素的值
    Status GetElem(LinkList L, int i, ElemType *e)
    {
        int j;
        LinkList p;  # 声明一结点p
        p = L -> next;  # 让p指向链表L的第一个结点
        j = 1;  # j为计数器
        while (p && j < i)  # p不为空或者计数器j还没有等于i时，循环继续
        {
            p = p -> next;  # 让p指向下一个结点
            ++j;
        }
        if (!p || j > i)
            return ERROR;  # 第i个元素不存在
        *e = p -> data;  # 取第i个元素的数据
        return OK;
    }

#### 1.4.5、单链表的插入和删除

单链表第i个数据插入结点的算法思路：1.声明一结点p指向链表第一个结点，初始化j从1开始；2.当j<1时，就遍历链表，让p的指针向后移动，不断指向
下一结点，j累加1；3.若到链表末尾p为空，则说明第i个元素不存在；4.否则查找成功，在系统中生成一个空结点s；5.将数据元素e赋值给s->data； 6.单链表的插入标准语句s->next=p->next；p->
next=s；7.返回成功。

    # 初始条件：单链表L已存在
    # 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度+1
    Status ListInsert(LinkList *L, int i, ElemType e)
    {
        int j;
        LinkList p,s;
        p = *L;
        j = 1;
        while (p && j < i)  # 寻找第i个结点
        {
            p = p -> next;
            ++j;
        }
        if (!p || j > i)
            return ERROR;  # 第i个元素不存在
        s = (LinkList)malloc(sizeof(Node));  # 生成新结点
        s -> data = e;  # 将数据元素e赋值给s
        # 这两处代码的顺序不能作改动，必须先将p的后继结点赋值给s的后继，再将s赋值给p的后继
        s -> next = p -> next;  # 将p的后继结点赋值给s的后继
        p -> next = s;  # 将s赋值给p的后继
        return OK;
    }

单链表的删除： 单链表第i个数据删除结点的算法思路：1.声明一结点p指向链表第一个结点，初始化j从1开始；2.当j<1时，就遍历链表，让p的指针向后移动，
不断指向下一个结点，j累加1；3.若到链表末尾p为空，则说明第i个元素不存在；4.否则查找成功，将欲删除的结点p->next赋值给q；5.单链表 的删除标准语句p->next=q->
next；6.将q结点中的数据赋值给e，作为返回；7.释放q结点；8.返回成功。

    # 初始条件：单链表L已存在
    # 操作结果： 删除L的第i个数据元素，并用e返回其值，L的长度-1
    Status ListDelete (LinkList *L, int i, ElemType *e)
    {
      int j;
      LinkList p, q;
      p = *L;
      j = 1;
      while (p -> next && j < i)  # 遍历寻找第i个元素
      {
        p = p -> next;
        ++j;
      }
      if (!(p -> next) || j > i)
        return EROR;  # 第i个元素不存在
      q = p -> next;
      p -> next = q -> next;  # 将q的后继赋值给p的后继
      *e = q -> data;  # 将q结点中的数据给e
      free(q);  # 让系统回收此结点，释放内存
      return OK;
    }

+ 单链表数据结构在插入和删除操作上，与线性表的顺序存储结构是没有太大优势的。但是对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显。
+

#### 1.4.6、单链表的整表创建

+ 单链表和顺序存储结构不一样，顺序存储结构很集中，单单链表很散，是一种动态结构。所占空间的大小和位置不需要预先分配划定，可以根据系统的情况 和实际需求即时生成。

    创建单链表的过程就是一个动态生成链表的过程(即从空表的初始状态起，依次建立各元素结点，并逐个插入链表)
    单链表整表创建的算法思路：**头插法**
    1.声明一结点p和计数器变量i； 2.初始化一空链表L； 3.让L的头结点的指针指向NULL，即建立一个带头结点的单链表；
    4.循环： 生成一新结点赋值给p；随机生成一数字赋值给p的数据域p->data； 将p插入到头结点与前一新结点之间。
    
    # 随机产生n个元素的值，建立带表头结点的单链线性表L
    void CreateListHead (LinkList *L, int n)
    {
    LinkList p;
    int i;
    srand(time(0));  # 初始化随机数种子
    *L = (LinkList)malloc(sizeof(Node))
    (*L) -> next = NULL;  # 建立一个带头结点的单链表
    for (i=0;i<n;i++)
      {
      p = (LinkList)malloc(sizeof(Node));  # 生成新结点
      p -> data = rand() % 100 +1;  # 随机生成100以内的数字
      p -> next = (*L) -> next;
      (*L) -> next = p;  # 插入到表头
      }
    }

#### 1.4.7、单链表结构和顺序存储结构

+ 存储分配方式：顺序存储结构用一段连续的存储单元依次存储线性表的数据元素；单链表采用链式存储结构，用一组任意的存储单元存放线性表的元素；
+ 时间性能：查找时：顺序存储结构为O(1)、单链表为O(n);插入和删除时：顺序存储结构为O(n)、单链表为O(1)。
+ 空间性能：顺序存储结构需要预分配存储空间，单链表不需要预先分配存储空间，只要有就可以分配，元素个数也不受限制。

#### 1.4.8、静态链表

+ 用数组描述的链表叫做静态链表。
+ 数组的元素都是由两个数据域组成 data用来存放数据元素 和 cur游标存放该元素的后继在数组中的下标
+ 将未被使用的数组元素称为 备用链表
+ 数组的第一个元素，即下标为0的元素的cur存放*备用链表*的第一个结点的下标，数组的最后一个元素的cur存放第一个有数值的元素的下标，即头结点
+

    # 线性表的静态链表存储结构
    #define MAXSIZE 1000  # 假设链表的最大长度是1000
    typedef struct
    {
     ElemType data;
     int cur;  # 游标，为0时表示无指向
    }
    Component, StaticLinkList[MAXSIZE];

#### 1.4.9、循环链表

+ 把单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。
+ 其实循环链表和单链表的主要差异在于 循环的判断条件上，原来是判断p->next是否为空，现在是p->next不等于头结点，则循环未结束。
+

#### 1.4.10、双向链表

+ double linked list 是在单链表的每个结点中再设置一个指向其前驱结点的指针域，即在双向链表中的结点有两个指针域，一个指向直接后继，一个指向直接前驱。

    typedef struct DulNode
    {
    ElemType data;
    struct DulNode *prior;
    struct DulNode *next;
    }
    DulNode, *DuLinkList;

### 1.5、栈和队列

#### 1.5.1、栈

+ 栈stack是限定仅在表尾进行插入和删除操作的线性表。
+ 允许插入和删除的一端称为栈顶top(表尾)，另一端称为栈底bottom，不含任何数据元素的栈称为空栈。栈底固定 进栈出栈只在栈底进行。
+ Last in first out的线性表，LIFO结构。
+ 栈是一个特殊的线性表，所以栈元素具有线性关系，即前驱后继关系。

#### 1.5.2、栈的抽象数据类型

    栈的结构定义
    typedef int SElemType;  # SElemType类型根据实际情况而定，这里假设是Int
    typedef struct
    {
      SElemType data[MAXSIZE];
      int top;  # 用于栈顶指针
    }
    SqStack;



    ADT 栈(stack)
    Data
      同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。
    Operation
      InitStack(*S)  # 初始化操作，建立一个空栈S
      DestroyStack(*S)  #  若栈存在，则销毁它
      ClearStack(*S)  # 将栈清空
      StackEmpty(S)  # 若栈为空，返回True。否则返回false
      GetTop(S, *e)  # 若栈存在且非空，用e返回S的栈顶元素
      Push(*S, e)  # 若栈S存在，插入新元素e到栈S中并成为栈顶元素
      Pop(*S, *e)  # 删除栈S中栈顶元素，并用e返回其值
      StackLength(S)  # 返回栈S的元素个数
    endADT

#### 1.5.3、两栈共享空间

这种数据结构适合 当两个栈的空间需求具有相反关系的时候，即一个栈增长时另一个栈在缩短的情况。

    # 两栈共享空间结构
    typedef struct
    {
      SElemType data[MAXSIZE];
      int top1;
      int top2;
    }
    SqDoubleStack;

#### 1.5.4、栈的链式存储结构

+ 链栈： 把栈顶放在单链表的头部，没有头结点。
+ 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，但这也不是链栈是否溢出的问题。
+ 链栈要求每个元素都有指针域，这同时也增加了一些内存开销，但对于栈的长度无限制。
+ 如果栈的使用过程中元素变化不可预料，最好是使用链栈，反之，若它的变化在可控范围内，建议使用顺序栈会更好一些。

    链栈的结构代码：
    typedef struct StackNode
    {
      SElemType data;
      struct StackNode *next;
    }
    StackNode, *LinkStackPtr;
    
    typedef struct LinkStack
    {
      LinkStackPtr top;
      int count;
    }
    LinkStack;

链栈的进栈push操作：

    Status Push (LinkStack *S, SElemType e)
    {
      LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode));
      s -> data = e;
      s -> next = S -> top;  # 把当前的栈顶元素赋值给新结点的直接后继
      S -> top = s;  # 将新的结点s赋值给栈顶指针
      S -> count++;
      return OK;
    }

#### 1.5.5、队列

+ 队列是一种先进先出first in first out的线性表，允许插入的一端为队尾，允许删除的一端为队头。

    队列的抽象数据类型：
    ADT 队列Queue
    Data
        同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
    Operation
        InitQueue(*Q)  # 初始化操作，建立一个空队列
        DestroyQueue(*Q)  # 若队列Q存在，则销毁它
        ClearQueue(*Q)  # 队列Q清空
        QueueEmpty(Q)  # 若队列Q为空，返回true，否则返回false
        GetHead(Q, *e)  # 若队列Q存在且非空，用e返回队列Q的队头元素
        EnQueue(*Q, e)  # 若队列Q存在，插入新元素e到队列Q中并成为队尾元素
        DeQueue(*Q, *e)  #  删除队列Q中队头严肃，并用e返回其值
        QueueLength(Q)  # 返回队列Q的元素个数
    endADT

+ 队列的顺序存储结构：队列元素的出列是在队头，即下标为0的位置，也就意味着队列中的所有元素都得向前移动，以保证队列的队头，即下标为0的位置不为空。时间复杂度为O(n)。
+

#### 1.5.6、循环队列的顺序存储结构

+ 头尾相接的顺序存储结构的队列称为循环队列。
+

    循环队列的顺序存储结构代码：
    typedef int QElemType;
    typedef struct
    {
      QElemType data[MAXSIZE];
      int front;  # 头指针
      int rear;  # 尾指针，若队列不空，指向队列尾元素的下一个位置
    }
    SqQueue;

    循环队列的初始化代码：
    Status InitQueue (SqQueue *Q)
    {
      Q -> front = 0;
      Q -> rear = 0;
      return OK;
    }

    循环队列求队列长度：
    # 返回Q的元素个数，也就是队列的当前长度
    int QueueLength (SqQueue Q)
    {
      return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
    }
    
    循环队列的入队列操作代码：
    # 若队列未满，则插入元素e为Q新的队尾元素
    Status EnQueue (SqQueue *Q, QElemType e)
    {
      if ((Q -> rear + 1) % MAXSIZE == Q -> front)  # 队列满的判断
        return ERROR;
      Q -> data[Q -> rear] = e;  # 将元素e赋值给队尾
      Q -> rear = (Q -> rear + 1) % MAXSIZE;  # rear指针向后移一位置，若到最后则转到数组头部
    return OK;
    }

    循环队列的出队列操作代码：
    # 若队列不空，则删除Q中队头元素，用e返回其值
    Status DeQueue (SqQueue *Q, QElemType *e)
    {
      if (Q -> front == Q -> rear)  # 队列空的判断
        return ERROR;
      *e = Q -> data[Q -> front];  # 将队头元素赋值给e
      Q -> front = (Q -> front + 1) % MAXSIZE;  # front指针向后移一位置，若到最后则转到数组头部
    return OK;
    }

#### 1.5.7、循环队列的链式存储结构

+ 队列的链式存储结构，其实就是线性表的单链表，只不过是它只能尾进头出而已，将其简称为 链队列。
+ 队头指针指向链队列的头结点，队尾指针指向终端结点。
+

### 1.6、串

#### 1.6.1、串 string

+ 串是由0个或多个字符组成的有限序列，又名叫 字符串。
+ 一般记为 s = "a1a2a3...an" n为是串中的字符数目，也是串的长度。
+ 零个字符的串称为 空串 null string

#### 1.6.2、串的比较

+ 串的比较是通过组成串的字符之间的编码进行的，字符的编码指的是字符在对应字符集中的序号。
+ 计算机中的常用字符是使用标准的ASCII编码，由7位二进制数表示一个字符，总共可以表示128个字符。后来扩展为8位。后来有了Unicode编码，由16位二进制数表示一个字符。
+ 串的逻辑结构和线性表相似，但针对的是字符集，所以基本操作和线性表有很大差异。
+ 线性表更关注的是单个元素的操作，比如查找一个元素、插入或删除一个元素，但串中更多的是查找子串的位置、得到指定位置子串、替换子串等操作。

    ADT 串 (string)
    Data
        串中元素仅由一个字符组成，相邻元素具有前驱和后继的关系。
    Operation
        StrAssign(T, *chars) # 生成一个其值等于字符串常量chars的串
        StrCopy(T,S)  # 串s存在，由串s复制得串T
        ClearString(S)  # 串S存在，将串清空
        StringEmpty(S)  # 若串S位空，返回true，否则返回false
        StrLength(S)  # 返回串S的元素个数，即串的长度
        StrCompare(S, T)  # 若S>T，返回值>0，若S=T，返回0，若S<T，返回值<0
        Concat(T, S1, S2)  # 用T返回由S1和S2联接而成的新串
        SubString(Sub, S, pos, len)  # 用sub返回串S的第pos个字符起长度位len的子串
        Index(S, T, pos) 
        Replace(S, T, V)
        StrInsert(S, pos, T)
        StrDelete(S, pos, len)
    endADT

#### 1.6.3、串的顺序存储结构和链式存储结构

+ 串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的
+ 串值的存储空间可以在程序执行过程中动态分配而得。


+ 串的链式存储结构和线性表是相似的，每个结点可以存放一个字符，也可以存放多个字符。

#### 1.6.4、串的朴素匹配算法和KMP模式匹配算法

### 1.7、树

#### 1.7.1、基本概念

+ tree树是n个结点的有限集。n=0时称为空树。在任意一棵非空树中：(1)有且仅有一个特定的称为根root的结点；(2)当n>1时，其余结点可分为m(m>0)
  个互不相交的有限集T1 T2 T3，其中每一个集合本身又是一棵树，并且称为根的子树subtree。
+ 树的结点包含一个数据元素及若干指向子树的分支。结点拥有的子树数称为 结点的度degree。度为0的结点称为叶结点leaf或终端结点；度不为0的结点称为非终端结点或分支结点。
+ 树的度是树内各结点的度的最大值。

+ 结点的子树的根称为该结点的孩子child，该结点称为child的parent。同一个双亲的child之间互称为sibling。结点的祖先是从根到该结点所经分支上的所有结点。以某结点为根的子数中的任一结点都称为该结点的子孙。
+ 树中结点的最大层次称为树的深度Depth或高度。
+ 结点的层次level从根开始定义起，根为第一层，根的孩子为第二层。
+ 森林forest是m课互不相交的树的集合，对树中的每个结点而言，其子树的集合即为森林。
+

#### 1.7.2、树的抽象数据类型

    ADT 树tree
    Data
        树是由一个根结点和若干棵子树构成的。树中结点具有相同数据类型及层次关系。
    Operation
        InitTree(*T)  # 构造空树T
        DestroyTree(*T)  # 销毁树T
        CreateTree(*T, definition)  # 按definition中给出树的定义来构造树
        ClearTree(*T)  # 若树T存在，则将树T清为空数
        TreeEmpty(T)  # 若T为空树，返回true，否则返回false
        TreeDepth(T)  # 返回T的深度
        Root(T)  # 返回T的根结点
        Value(T, cur_e)  # cur_e 是树T中一个结点，返回此结点的值
        Assign(T, cur_e, value)  # 给树T的结点cur_e赋值为value
        Parent(T, cur_e)  # 若cur_e是树T的非根结点，则返回它的双亲，否则返回空
        LeftChild(T, cur_e)  # 若cur_e是树T的非叶结点，则返回它的最左孩子，否则返回空
        RightSibling(T, cur_e)  # 若cur_e有右兄弟，则返回它的右兄弟，否则返回空
        InsertChild(*T, *p, i, c)  # 其中p指向树T的某个结点，i为所指结点p的度+1
        DeleteChild(*T, *p, i)  # 其中p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵树
    endADT

#### 1.7.3、树的存储结构

`双亲表示法`:
假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。即，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。
其中，data是数据域，存储结点的数据信息。而parent是指针域，存储该结点的双亲在数组中的下标。  
需要约定根结点的位置域设置为-1，因为根结点是没有双亲的。

    #define MAX_TREE_SIZE 100
    typedef int TElemType;  # 树结点的数据类型，整型
    typedef struct PTNode  # 结点结构
    {
        TElemType data;  # 结点数据
        int parent;  # 双亲位置
    }
    PTNode;
    typedef struct  # 树结构
    {
        PTNode nodes[MAX_TREE_SIZE];  # 结点数组
        int r, n;  # 根的位置和结点数
    }
    PTree;

+ 这样的存储结构，根据结点的parent指针可以很容易找到它的双亲结点。
+ 如果结点的孩子很多，超过了2个。我们又关注结点的双亲、又关注结点的孩子、还关注结点的兄弟，而且对时间遍历要求还比较高，那么就可以将这个结构扩展为双亲域、长子域、右兄弟域等。
+

#### 1.7.4、二叉树

+ 二叉树 binary tree 是n个结点的有限集合，该集合或者为空集，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。

二叉树的特点： 1.每个结点最多有两棵子树，所以二叉树不存在度大于2的结点。当然，没有子树或者有一棵子树都是可以的。 2.左子树和右子树是有顺序的，次序不能任意颠倒。 3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

二叉树具有五种基本形态： 空二叉树、只有一个根结点、根结点只有左子树、根结点只有右子树、根结点既有左子树又有右子树

`斜树`  `满二叉树`  `完全二叉树`

#### 1.7.5、二叉树的顺序存储结构

+ 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，即数组的下标要能体现结点之间的逻辑关系。
+ 考虑一种极端情况，一棵深度为k的右斜树，只有k个结点，却需要分配2^k-1个存储单元空间，这显然是对存储空间的浪费，所以，顺序存储结构一般只用于完全二叉树。
+ 二叉树的顺序存储结构适用性不强。

#### 1.7.6、二叉链表

+ 二叉树每个结点最多有两个孩子，所以链表的每个结点设计一个数据域和两个指针域，这样的链表称为 二叉链表。
    +

    # 二叉树的二叉链表的结点结构定义
    typedef struct BiTNode  # 结点结构
    {
      TElemType data;  # 结点数据
      struct BiTNode *lchild, *rchild;  # 左右孩子指针
    }
    BiTNode, *BiTree;

#### 1.7.7、二叉树遍历

+ traversing binary tree 遍历二叉树 是指从根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问依次且仅被访问一次。
+ 访问： 其实是要根据实际的需要来确定具体要做什么
+ 次序：二叉树的遍历次数不同于线性结构，最多就是 从头至尾、循环、双向等简单的遍历方式。树的结点之间不存在唯一的前驱和后继的关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。
+ 遍历方法：前序遍历，中序遍历，后序遍历，层序遍历

`前序遍历`  若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。
`中序遍历`  若树为空，则空操作返回，否则从根结点开始（但不是先访问根结点），中序遍历根结点左边的树，然后访问根结点，最后中序遍历右子树。
`后序遍历`  若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后访问根结点。
`层序遍历`  若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

    前序遍历算法：  核心就是 递归
    void PreOrderTraverse (BiTree T)
    {
        if (T == NULL)
          return;
        printf("%c", T -> data);  # 显示结点数据
        PreOrderTraverse(T -> lchild);  # 再先序遍历左子树
        PreOrderTraverse(T -> rchild);  # 最后先序遍历右子树
    }

##### 1.7.8、二叉树的建立

+ 建立二叉树前要对二叉树处理，得到扩展二叉树。扩展二叉树就可以得到一个遍历序列确定一棵二叉树了。

    # 按前序输入二叉树中结点的值
    # #表示空树，构造二叉链表表示二叉树T
    void CreateBiTree (BiTree *T)
    {
        TElemType ch;
        scanf("%c", &ch);
        if (ch == '#')
            *T = NULL;
        else
        {
          *T = (BiTree)malloc(sizeof(BiTNode));
          if (!*T)
            exit(OVERFLOW);
          (*T) -> data = ch;
          CreateBiTree(&(*T) -> lchild);  # 构造左子树
          CreateBiTree(&(*T) -> rchild);  # 构造右子树
        }
    }

#### 1.7.9、线索二叉树

+ 把指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树 threaded binary tree
+ 线索二叉树就是将一棵二叉树转变成一个双向链表
+ 对二叉树以某种次序遍历使其变成线索二叉树的过程称为线索化。

    # 二叉树的二叉线索存储结构定义
    typedef enum {Link, Thread} PointerTag;  # Link==0表示指向左右孩子指针 Thread==1表示指向前驱或后继的线索
    typedef struct BiThrNode  # 二叉线索存储结点结构
    {
      TElemType data;  # 结点数据
      struct BiThrNode *lchild, *rchild;  # 左右孩子指针
      PointerTag LTag;
      PointerTag RTag;  # 左右标志
    }
    BiThrNode, * BiThrTree;

线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索，由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化 的过程就是在遍历的过程中修改空指针的过程。

#### 1.7.10、树与森林的遍历

+ 树的遍历：1.先根遍历树，再依次先根遍历根的每棵子树；2.后根遍历，再访问根结点。
+ 森林的遍历：1.前序遍历 先访问森林中第一棵树的根结点，再依次先根遍历根的每棵子树，再依次遍历除去第一棵树的剩余树构成的森林； 2.后序遍历
+

#### 1.7.11、赫夫曼树

+ 从树上一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称作路径长度。
+ 树的路径长度就是从树根到每一结点的路径长度之和。
+ 赫夫曼树就是带权路径长度WPL最小的二叉树

### 1.8、图graph

+ 图graph 是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V, E)。其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。
+ 在线性表中，数据元素叫元素，树中叫结点，图中叫顶点vertex
+ 无向边：若顶点vi到vj之间的边没有方向，则称这条边为无向边edge，用无序偶对(vi, vj)来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无向图undirected graphs
+ 有向边：若从顶点vi到vj的边有方向，则称这条边为有向边，也称为弧arc
+ 如果图中任意两个顶点之间的边都是有向边，则称该图为有向图。
+ 与边/弧相关的数较为权weight，权可以表示从一个顶点到另一个顶点的距离或耗费，这种带权的图通常称为网network
+

#### 1.8.1、图的抽象数据类型

    ADT 图graph
    Data
        顶点的有穷非空集合和边的集合
    Operation
        CreateGraph(*G, V, VR)  # 按照顶点集V和边弧集VR的定义构造图G
        DestroyGraph(*G)  # 图G存在则销毁
        LocateVex(G, u)  # 若图G中存在顶点u，则返回图中的位置
        GetVex(G,v)  # 返回图G中顶点v的值
        PutVex(G,v, value)  # 将图G中顶点v赋值value
        FirstAdjVex(G, *v)  # 返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空
        NextAdjVex(G, v, *w)  # 返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后一个邻接点则返回NULL
        InsertVex(*G, v)  # 在图G中增添新顶点v
        DeleteVex(*G, v)  # 删除图G中顶点v及其相关的弧
        InsertArc(*G, v, w)  # 在图G中增添弧<v, w>，若G是无向图，还需要增添对称弧<w,v>
        DeleteArc(*G, v w)  # 在图G中删除弧
        DFSTraverse(G)  # 深度优先遍历
        HFSTraverse(G)  # 广度优先遍历
    endADT

#### 1.8.2、图的存储结构

+ 采用邻接矩阵adjacency matrix 存储图
+ 将数组和链表相结合存储图的存储方法 adjacency list

#### 1.8.3、DFS BFS

### 二、排序算法

+ 主要是十大排序算法，可以分为两类：非线性时间比较类排序，线性时间非比较类排序
+ 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面
+ 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面

|排序方法|时间复杂度(最坏)|空间复杂度|稳定性|
|:-----:|:-----:|:-----:|:-----:|
|插入排序|O(n^2)|O(1)|稳定|
|希尔排序|O(n^2)|O(1)|不稳定|
|选择排序|O(n^2)|O(1)|不稳定|
|堆排序|O(nlog2(n))|O(1)|不稳定|
|冒泡排序|O(n^2)|O(1)|稳定|
|快速排序|O(nlog2(n))|O(nlog2(n))|不稳定|
|归并排序|O(nlog2(n))|O(n)|稳定|
|计数排序|O(n+k)|O(n+k)|稳定|
|桶排序|O(n^2)|O(n+k)|稳定|
|基数排序|O(n*k)|O(n+k)|稳定|














